scriptencoding utf-8
se nocompatible
" vim-plug =================================================
let g:plug_threads=2

call plug#begin('~/.vim/plugged')

" toml -----------------------------------------------------
" for cargo (rust) files
Plug 'cespare/vim-toml', { 'for': 'toml' }

" markdown -------------------------------------------------
Plug 'godlygeek/tabular', { 'for': 'markdown' }
Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }

" rust stuff -----------------------------------------------
Plug 'rust-lang/rust.vim', { 'for': 'rust' }
Plug 'racer-rust/vim-racer', { 'for': 'rust' }

" general --------------------------------------------------
" Underline words under the cursor
Plug 'itchyny/vim-cursorword'

" Molokai colorscheme
Plug 'tomasr/molokai'

Plug 'Shougo/vimproc.vim', { 'do': 'make'}
Plug 'ajh17/VimCompletesMe'
Plug 'mbbill/undotree'
Plug 'romainl/vim-cool'
Plug 'justinmk/vim-sneak'
Plug 'tpope/vim-surround'
Plug 'editorconfig/editorconfig-vim'
Plug 'vim-scripts/haskell.vim'

call plug#end()

" general ==================================================
filetype plugin indent on
se ambiwidth=single
se autochdir
se autoindent
se autoread
se backspace=2
se clipboard=unnamed
se cmdheight=1
se colorcolumn=60
se conceallevel=0
se confirm
se cursorcolumn
se cursorline
se dir=~/.vim/swp//
se encoding=utf-8
se expandtab
se fileencoding=utf-8
se foldcolumn=1
se foldenable
se foldmethod=indent
se foldnestmax=3
se hidden
se incsearch
se laststatus=2
se linebreak
se noerrorbells
se hlsearch
se noruler
se nospell
se novisualbell
se nowrap
se number
se numberwidth=1
se complete=.,w,b,u,U,t
se nrformats=alpha,hex,bin
se omnifunc=syntaxcomplete#Complete
se relativenumber
se scrolljump=10
se scrolloff=5
se shiftwidth=4
se shortmess=at
se showcmd
se showmode
se showtabline=1
se smartindent
se smarttab
se softtabstop=0
se splitbelow
se splitright
se t_Co=256
se t_vb=
se tabpagemax=30
se tabstop=8
se ttimeoutlen=0 " status bar change mode delay (ms)
se viminfo+=n~/.vim/viminfo
se wildignore+=*.swp,*.o
se wildmenu
se matchpairs=(:),[:],{:},<:>
highlight comment cterm=italic
syntax on
"se mouse=a

if has("persistent_undo")
    set undodir=~/.vim/undo
    set undofile
endif

" Status Line ==============================================
se statusline=%(#%n\ %f%)\  " #buf fname
se statusline+=%(%m%r%h%w%) " modified/modifiable/etc
se statusline+=%y%=\  " ftype
se statusline+=%{strlen(&fenc)?&fenc:'none'}: "file encoding
se statusline+=%{&ff}\ \|\  "file format
se statusline+=%(%l:%c\ \|\ %L\ \|\ %) " #L:#C | #TL |

" leader/localleader
let mapleader=','
let maplocalleader=''

" undotree settings
nnoremap <LOCALLEADER>u :EightiesDisable<CR>:UndotreeToggle<CR>:EightiesEnable<CR>
let g:undotree_WindowLayout=2
let g:undotree_SetFocusWhenToggle=1
let g:undotree_HighlightChangedText=0
let g:undotree_ShortIndicators=1

" vim-eighties
let g:eighties_enabled = 1
let g:eighties_minimum_width = 65
let g:eighties_extra_width = 0 " Increase this if you want some extra room
let g:eighties_compute = 0 " Disable this if you just want the minimum + extra
let g:eighties_bufname_additional_patterns = [] " Defaults to [], 'fugitiveblame' is only an example. Takes a comma delimited list of bufnames as strings.

" sneak
let g:sneak#label = 1

" Rust Settings ============================================
" rustfmt
let g:rustfmt_autosave=1

" racer
let g:racer_cmd="~/.cargo/bin/racer"
let g:racer_experimental_completer=0

" bindings -------------------------------------------------
" = buffer/function
nnoremap <LEADER>M maggVG=`a_zz
nnoremap <LEADER>m ma]][[V%=`a_zz

nnoremap ZZ :w<CR>
nnoremap QQ :q!<CR>
nnoremap ZQ :x<CR>

" movement keys
nnoremap <C-J> 5j
nnoremap <C-K> 5k
vnoremap <C-J> 5j
vnoremap <C-K> 5k
nnoremap B b
nnoremap E e
nnoremap W w
nnoremap b B
nnoremap e E
nnoremap w W
vnoremap B b
vnoremap E e
vnoremap W w
vnoremap b B
vnoremap e E
vnoremap w W

"bye bye arrow keys
"inoremap <DOWN> <NOP>
"nnoremap <DOWN> <NOP>
"vnoremap <DOWN> <NOP>
"inoremap <LEFT> <NOP>
"nnoremap <LEFT> <NOP>
"vnoremap <LEFT> <NOP>
"inoremap <RIGHT> <NOP>
"nnoremap <RIGHT> <NOP>
"vnoremap <RIGHT> <NOP>
"inoremap <UP> <NOP>
"nnoremap <UP> <NOP>
"vnoremap <UP> <NOP>

nnoremap <SPACE> za

" move cursor to the beggining/end of the line
nnoremap gh _
nnoremap gl $
nnoremap gj G
nnoremap gk gg
vnoremap gh _
vnoremap gl $
vnoremap gj G
vnoremap gk gg

" swap visual and visual block
nnoremap v <C-V>
nnoremap <C-V> v

" search
vnoremap / y/<C-R>"<CR>

" search and replace
nnoremap <C-S> :%s/<cword>//cg<LEFT><LEFT><LEFT>
vnoremap <C-S> y:%s/<C-R>"//cg<LEFT><LEFT><LEFT>
nnoremap <F7> :cprevious<CR>
nnoremap <F8> :cnext<CR>

" vimrc edit
nnoremap <LEADER>ev :e $MYVIMRC<CR>

" tabs
nnoremap <LOCALLEADER>1 1gt
nnoremap <LOCALLEADER>2 2gt
nnoremap <LOCALLEADER>3 3gt
nnoremap <LOCALLEADER>4 4gt
nnoremap <LOCALLEADER>5 5gt
nnoremap <LOCALLEADER>6 6gt
nnoremap <LOCALLEADER>7 7gt
nnoremap <LOCALLEADER>8 8gt
nnoremap <LOCALLEADER>9 9gt
nnoremap <LOCALLEADER>l gt
nnoremap <LOCALLEADER>h gT
nnoremap <C-W>tn :tabnew 
nnoremap <C-W>tq :tabclose<CR>

" windows
nnoremap <C-W>tf <C-W>f<C-W>T
nnoremap <C-W>q :bdelete<CR>
nnoremap <C-W>n :new 
nnoremap <C-W>v :vnew 
nnoremap <C-L> :ls<CR>

" put stuff around words
nnoremap <LEADER>" viW<ESC>`>a"<ESC>`<i"<ESC>
nnoremap <LEADER>' viW<ESC>`>a'<ESC>`<i'<ESC>
nnoremap <LEADER>` viW<ESC>`>a`<ESC>`<i`<ESC>
nnoremap <LEADER>( viW<ESC>`>a)<ESC>`<i(<ESC>
nnoremap <LEADER>) viW<ESC>`>a)<ESC>`<i(<ESC>
nnoremap <LEADER>[ viW<ESC>`>a]<ESC>`<i[<ESC>
nnoremap <LEADER>] viW<ESC>`>a]<ESC>`<i[<ESC>
nnoremap <LEADER>{ viW<ESC>`>a}<ESC>`<i{<ESC>
nnoremap <LEADER>} viW<ESC>`>a}<ESC>`<i{<ESC>
nnoremap <LEADER>< viW<ESC>`>a><ESC>`<i<<ESC>
nnoremap <LEADER>> viW<ESC>`>a><ESC>`<i<<ESC>

" put stuff around selected text
vnoremap <LEADER>" <ESC>`>a"<ESC>`<i"<ESC>
vnoremap <LEADER>' <ESC>`>a'<ESC>`<i'<ESC>
vnoremap <LEADER>` <ESC>`>a`<ESC>`<i`<ESC>
vnoremap <LEADER>( <ESC>`>a)<ESC>`<i(<ESC>
vnoremap <LEADER>) <ESC>`>a)<ESC>`<i(<ESC>
vnoremap <LEADER>[ <ESC>`>a]<ESC>`<i[<ESC>
vnoremap <LEADER>] <ESC>`>a]<ESC>`<i[<ESC>
vnoremap <LEADER>{ <ESC>`>a}<ESC>`<i{<ESC>
vnoremap <LEADER>} <ESC>`>a}<ESC>`<i{<ESC>
vnoremap <LEADER>< <ESC>`>a><ESC>`<i<<ESC>
vnoremap <LEADER>> <ESC>`>a><ESC>`<i<<ESC>

" abrevs ===================================================
iabbrev adn and
iabbrev amx max
iabbrev itn int
iabbrev reurnt return
iabbrev tehn then
iabbrev tepydef typedef
iabbrev waht what
iabbrev strutc struct
iabbrev flaot float

" invisibles ===============================================
se nolist
se listchars=tab:\|â–¸,eol:Â¬,trail:âˆ™
"se listchars=tab:>~,trail:.
nnoremap <C-P> :se list!<CR>

" NETRW files browser ===============================
let g:netrw_liststyle=3 " listing style
let g:netrw_browse_split=0 " opening behaviour
map <C-E> :Explore<CR>

" monokai theme ============================================
colorscheme molokai
let g:molokai_original=1
let g:rehash256=1

" tabular ==================================================
let g:tabular_loaded=1

" vim-markdown =============================================
let g:vim_markdown_folding_disabled=0
let g:vim_markdown_folding_style_pythonic=0
let g:vim_markdown_folding_level=1
let g:vim_markdown_no_default_key_mappings=1
let g:vim_markdown_toc_autofit=1
let g:vim_markdown_emphasis_multiline=0
let g:vim_markdown_math=0

" tags support for Rust
autocmd BufRead *.rs :setlocal tags=./.tags;/,$RUST_SRC_PATH/.tags
autocmd BufWrite *.rs :silent! exec "!rusty-tags vi --quiet --start-dir=" . expand('%:p:h') . "&"

runtime macros/matchit.vim
autocmd QuickFixCmdPost [^l]* nested cwindow
autocmd QuickFixCmdPost    l* nested lwindow
autocmd VimEnter * echo "Fuck You Human .l."
